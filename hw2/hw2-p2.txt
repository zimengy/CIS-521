3.15

a.
                   1
             /         \
            2           3
          /   \       /   \
         4     5     6     7
        / \   / \   / \   / \ 
       8   9 10 11 12 13 14  15

b.
 breadth-first search: 1,2,3,4,5,6,7,8,9,10,11
 depth-limited search with limit 3: 1,2,4,8,9,5,10,11
 iterative deepening search: 1;1,2,3;1,2,4,5,3,6,7;1,2,4,8,9,5,10,11


c.Bidirectional search would work pretty well on this problem, because when you do backward search, one state only have one successor.
Branching factor forward: 2, backward: 1


d.If we search from the goal and do backward search, every state only has one successor. So it will eventually leads to state 1.


e.
If we need to search state n, first check if n is an even number or odd number. If it's even, the last action is Left; if it's odd the last action is Right. Then iteratively divide n by 2 and round down to the nearest integer. And each time check if the integer is even or odd to decide if this time the action is Left or Right. Finally stop until the integer becomes 1. The sequence of actions are in the reverse order of what is generated by each step.
For example if we want to search 11, 
11->odd: Right
11/2=5->odd: Right
5/2=2->even: Left
2/2=1: stop
So the sequence of actions are: Left, Right, Right

